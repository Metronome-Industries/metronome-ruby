module MetronomeSDK
  module Models
    module V1
      type billable_metric_retrieve_response =
        { data: MetronomeSDK::Models::V1::BillableMetricRetrieveResponse::Data }

      class BillableMetricRetrieveResponse < MetronomeSDK::Internal::Type::BaseModel
        attr_accessor data: MetronomeSDK::Models::V1::BillableMetricRetrieveResponse::Data

        def initialize: (
          data: MetronomeSDK::Models::V1::BillableMetricRetrieveResponse::Data
        ) -> void

        def to_hash: -> {
          data: MetronomeSDK::Models::V1::BillableMetricRetrieveResponse::Data
        }

        type data =
          {
            id: String,
            name: String,
            aggregation_key: String,
            aggregation_type: MetronomeSDK::Models::V1::BillableMetricRetrieveResponse::Data::aggregation_type,
            archived_at: Time,
            custom_fields: ::Hash[Symbol, String],
            event_type_filter: MetronomeSDK::Models::V1::BillableMetricRetrieveResponse::Data::EventTypeFilter,
            group_keys: ::Array[::Array[String]],
            property_filters: ::Array[MetronomeSDK::Models::V1::BillableMetricRetrieveResponse::Data::PropertyFilter],
            sql: String
          }

        class Data < MetronomeSDK::Internal::Type::BaseModel
          attr_accessor id: String

          attr_accessor name: String

          attr_reader aggregation_key: String?

          def aggregation_key=: (String) -> String

          attr_reader aggregation_type: MetronomeSDK::Models::V1::BillableMetricRetrieveResponse::Data::aggregation_type?

          def aggregation_type=: (
            MetronomeSDK::Models::V1::BillableMetricRetrieveResponse::Data::aggregation_type
          ) -> MetronomeSDK::Models::V1::BillableMetricRetrieveResponse::Data::aggregation_type

          attr_reader archived_at: Time?

          def archived_at=: (Time) -> Time

          attr_reader custom_fields: ::Hash[Symbol, String]?

          def custom_fields=: (::Hash[Symbol, String]) -> ::Hash[Symbol, String]

          attr_reader event_type_filter: MetronomeSDK::Models::V1::BillableMetricRetrieveResponse::Data::EventTypeFilter?

          def event_type_filter=: (
            MetronomeSDK::Models::V1::BillableMetricRetrieveResponse::Data::EventTypeFilter
          ) -> MetronomeSDK::Models::V1::BillableMetricRetrieveResponse::Data::EventTypeFilter

          attr_reader group_keys: ::Array[::Array[String]]?

          def group_keys=: (
            ::Array[::Array[String]]
          ) -> ::Array[::Array[String]]

          attr_reader property_filters: ::Array[MetronomeSDK::Models::V1::BillableMetricRetrieveResponse::Data::PropertyFilter]?

          def property_filters=: (
            ::Array[MetronomeSDK::Models::V1::BillableMetricRetrieveResponse::Data::PropertyFilter]
          ) -> ::Array[MetronomeSDK::Models::V1::BillableMetricRetrieveResponse::Data::PropertyFilter]

          attr_reader sql: String?

          def sql=: (String) -> String

          def initialize: (
            id: String,
            name: String,
            ?aggregation_key: String,
            ?aggregation_type: MetronomeSDK::Models::V1::BillableMetricRetrieveResponse::Data::aggregation_type,
            ?archived_at: Time,
            ?custom_fields: ::Hash[Symbol, String],
            ?event_type_filter: MetronomeSDK::Models::V1::BillableMetricRetrieveResponse::Data::EventTypeFilter,
            ?group_keys: ::Array[::Array[String]],
            ?property_filters: ::Array[MetronomeSDK::Models::V1::BillableMetricRetrieveResponse::Data::PropertyFilter],
            ?sql: String
          ) -> void

          def to_hash: -> {
            id: String,
            name: String,
            aggregation_key: String,
            aggregation_type: MetronomeSDK::Models::V1::BillableMetricRetrieveResponse::Data::aggregation_type,
            archived_at: Time,
            custom_fields: ::Hash[Symbol, String],
            event_type_filter: MetronomeSDK::Models::V1::BillableMetricRetrieveResponse::Data::EventTypeFilter,
            group_keys: ::Array[::Array[String]],
            property_filters: ::Array[MetronomeSDK::Models::V1::BillableMetricRetrieveResponse::Data::PropertyFilter],
            sql: String
          }

          type aggregation_type = :COUNT | :LATEST | :MAX | :SUM | :UNIQUE

          module AggregationType
            extend MetronomeSDK::Internal::Type::Enum

            COUNT: :COUNT
            LATEST: :LATEST
            MAX: :MAX
            SUM: :SUM
            UNIQUE: :UNIQUE

            def self?.values: -> ::Array[MetronomeSDK::Models::V1::BillableMetricRetrieveResponse::Data::aggregation_type]
          end

          type event_type_filter =
            { in_values: ::Array[String], not_in_values: ::Array[String] }

          class EventTypeFilter < MetronomeSDK::Internal::Type::BaseModel
            attr_reader in_values: ::Array[String]?

            def in_values=: (::Array[String]) -> ::Array[String]

            attr_reader not_in_values: ::Array[String]?

            def not_in_values=: (::Array[String]) -> ::Array[String]

            def initialize: (
              ?in_values: ::Array[String],
              ?not_in_values: ::Array[String]
            ) -> void

            def to_hash: -> {
              in_values: ::Array[String],
              not_in_values: ::Array[String]
            }
          end

          type property_filter =
            {
              name: String,
              exists: bool,
              in_values: ::Array[String],
              not_in_values: ::Array[String]
            }

          class PropertyFilter < MetronomeSDK::Internal::Type::BaseModel
            attr_accessor name: String

            attr_reader exists: bool?

            def exists=: (bool) -> bool

            attr_reader in_values: ::Array[String]?

            def in_values=: (::Array[String]) -> ::Array[String]

            attr_reader not_in_values: ::Array[String]?

            def not_in_values=: (::Array[String]) -> ::Array[String]

            def initialize: (
              name: String,
              ?exists: bool,
              ?in_values: ::Array[String],
              ?not_in_values: ::Array[String]
            ) -> void

            def to_hash: -> {
              name: String,
              exists: bool,
              in_values: ::Array[String],
              not_in_values: ::Array[String]
            }
          end
        end
      end
    end
  end
end

module Metronome
  module Models
    type plan_list_charges_response =
      {
        id: String,
        charge_type: Metronome::Models::PlanListChargesResponse::charge_type,
        credit_type: Metronome::Models::CreditTypeData,
        custom_fields: Hash[Symbol, String],
        name: String,
        prices: Array[Metronome::Models::PlanListChargesResponse::Price],
        product_id: String,
        product_name: String,
        quantity: Float,
        start_period: Float,
        tier_reset_frequency: Float,
        unit_conversion: Metronome::Models::PlanListChargesResponse::UnitConversion
      }

    class PlanListChargesResponse < Metronome::BaseModel
      attr_accessor id: String

      attr_accessor charge_type: Metronome::Models::PlanListChargesResponse::charge_type

      attr_accessor credit_type: Metronome::Models::CreditTypeData

      attr_accessor custom_fields: Hash[Symbol, String]

      attr_accessor name: String

      attr_accessor prices: Array[Metronome::Models::PlanListChargesResponse::Price]

      attr_accessor product_id: String

      attr_accessor product_name: String

      attr_reader quantity: Float?

      def quantity=: (Float) -> void

      attr_reader start_period: Float?

      def start_period=: (Float) -> void

      attr_reader tier_reset_frequency: Float?

      def tier_reset_frequency=: (Float) -> void

      attr_reader unit_conversion: Metronome::Models::PlanListChargesResponse::UnitConversion?

      def unit_conversion=: (
        Metronome::Models::PlanListChargesResponse::UnitConversion
      ) -> void

      def initialize:
        (
          id: String,
          charge_type: Metronome::Models::PlanListChargesResponse::charge_type,
          credit_type: Metronome::Models::CreditTypeData,
          custom_fields: Hash[Symbol, String],
          name: String,
          prices: Array[Metronome::Models::PlanListChargesResponse::Price],
          product_id: String,
          product_name: String,
          quantity: Float,
          start_period: Float,
          tier_reset_frequency: Float,
          unit_conversion: Metronome::Models::PlanListChargesResponse::UnitConversion
        ) -> void
        | (
          ?Metronome::Models::plan_list_charges_response
          | Metronome::BaseModel data
        ) -> void

      def to_hash: -> Metronome::Models::plan_list_charges_response

      type charge_type = :usage | :fixed | :composite | :minimum | :seat

      class ChargeType < Metronome::Enum
        USAGE: :usage
        FIXED: :fixed
        COMPOSITE: :composite
        MINIMUM: :minimum
        SEAT: :seat

        def self.values: -> Array[Metronome::Models::PlanListChargesResponse::charge_type]
      end

      type price =
        {
          tier: Float,
          value: Float,
          collection_interval: Float,
          collection_schedule: String,
          quantity: Float
        }

      class Price < Metronome::BaseModel
        attr_accessor tier: Float

        attr_accessor value: Float

        attr_reader collection_interval: Float?

        def collection_interval=: (Float) -> void

        attr_reader collection_schedule: String?

        def collection_schedule=: (String) -> void

        attr_reader quantity: Float?

        def quantity=: (Float) -> void

        def initialize:
          (
            tier: Float,
            value: Float,
            collection_interval: Float,
            collection_schedule: String,
            quantity: Float
          ) -> void
          | (
            ?Metronome::Models::PlanListChargesResponse::price
            | Metronome::BaseModel data
          ) -> void

        def to_hash: -> Metronome::Models::PlanListChargesResponse::price
      end

      type unit_conversion =
        {
          division_factor: Float,
          rounding_behavior: Metronome::Models::PlanListChargesResponse::UnitConversion::rounding_behavior
        }

      class UnitConversion < Metronome::BaseModel
        attr_accessor division_factor: Float

        attr_reader rounding_behavior: Metronome::Models::PlanListChargesResponse::UnitConversion::rounding_behavior?

        def rounding_behavior=: (
          Metronome::Models::PlanListChargesResponse::UnitConversion::rounding_behavior
        ) -> void

        def initialize:
          (
            division_factor: Float,
            rounding_behavior: Metronome::Models::PlanListChargesResponse::UnitConversion::rounding_behavior
          ) -> void
          | (
            ?Metronome::Models::PlanListChargesResponse::unit_conversion
            | Metronome::BaseModel data
          ) -> void

        def to_hash: -> Metronome::Models::PlanListChargesResponse::unit_conversion

        type rounding_behavior = :floor | :ceiling

        class RoundingBehavior < Metronome::Enum
          FLOOR: :floor
          CEILING: :ceiling

          def self.values: -> Array[Metronome::Models::PlanListChargesResponse::UnitConversion::rounding_behavior]
        end
      end
    end
  end
end
